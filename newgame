import pygame
import random
import sys
import math
import time
from pathlib import Path

# Initialize pygame
pygame.init()
pygame.mixer.init()  # Initialize sound mixer

# Screen dimensions
WIDTH, HEIGHT = 800, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Enhanced Treasure Hunter Adventure")

# Colors
BLUE = (100, 149, 237)
GREEN = (34, 139, 34)
BROWN = (139, 69, 19)
GOLD = (255, 215, 0)
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
SAND = (244, 215, 177)
WATER = (65, 105, 225)
GRASS = (124, 252, 0)
ROCK = (128, 128, 128)
DARK_GREEN = (0, 100, 0)
TREE_TRUNK = (101, 67, 33)
LIGHT_SAND = (253, 245, 230)
DIRT = (160, 120, 90)
RED = (255, 0, 0)
PURPLE = (128, 0, 128)
ORANGE = (255, 165, 0)
DARK_BLUE = (0, 0, 139)

# Game states
MENU = 0
DIFFICULTY_SELECT = 1
PLAYING = 2
CHALLENGE = 3
GAME_OVER = 4
SHOP = 5
PAUSE = 6
TUTORIAL = 7
STORY = 8

# Challenge types
COLLECTING = 0
SPENDING = 1
TREASURES = 2
SHARING = 3
MAPPING = 4
CODES = 5
SECRETS = 6
FRACTIONS = 7
TIME = 8
MONEY = 9
GEOMETRY = 10
MEASUREMENT = 11

# Load sounds - create placeholder paths (you'll need to add actual sound files)
sound_dir = Path('sounds')
sound_dir.mkdir(exist_ok=True)

# Dictionary to store sounds
sounds = {}

# Function to load sounds safely
def load_sound(name, filename):
    sound_path = sound_dir / filename
    try:
        if sound_path.exists():
            sounds[name] = pygame.mixer.Sound(str(sound_path))
        else:
            print(f"Sound file not found: {sound_path}")
    except pygame.error:
        print(f"Unable to load sound: {sound_path}")

# Load sound effects
sound_files = {
    'collect_key': 'key.wav',
    'collect_treasure': 'treasure.wav',
    'correct_answer': 'correct.wav',
    'wrong_answer': 'wrong.wav',
    'game_over': 'gameover.wav',
    'level_up': 'levelup.wav',
    'menu_select': 'select.wav',
    'walk': 'walk.wav',
    'shop_buy': 'buy.wav'
}

for name, file in sound_files.items():
    load_sound(name, file)

# Function to play sound safely
def play_sound(name):
    if name in sounds:
        sounds[name].play()

# Fonts
font_large = pygame.font.SysFont('comicsansms', 48)
font_medium = pygame.font.SysFont('comicsansms', 32)
font_small = pygame.font.SysFont('comicsansms', 24)
font_tiny = pygame.font.SysFont('comicsansms', 16)

# Particle system for visual effects
class Particle:
    def __init__(self, x, y, color, size=5, lifetime=60):
        self.x = x
        self.y = y
        self.color = color
        self.size = size
        self.lifetime = lifetime
        self.max_lifetime = lifetime
        self.velocity_x = random.uniform(-2, 2)
        self.velocity_y = random.uniform(-2, 2)
        
    def update(self):
        self.x += self.velocity_x
        self.y += self.velocity_y
        self.size = max(0, self.size - 0.1)
        self.lifetime -= 1
        
    def draw(self, camera_x, camera_y):
        screen_x = self.x - camera_x
        screen_y = self.y - camera_y
        alpha = int(255 * (self.lifetime / self.max_lifetime))
        color = (*self.color[:3], alpha) if len(self.color) > 3 else self.color
        
        if 0 <= screen_x <= WIDTH and 0 <= screen_y <= HEIGHT:
            pygame.draw.circle(screen, color, (int(screen_x), int(screen_y)), int(self.size))
            
    def is_dead(self):
        return self.lifetime <= 0

# Map generation
class Tile:
    def __init__(self, type, x, y, size):
        self.type = type
        self.x = x
        self.y = y
        self.size = size
        # Random variation for decoration positioning
        self.decoration_offset_x = random.randint(-size//4, size//4)
        self.decoration_offset_y = random.randint(-size//4, size//4)
        self.tree_height = random.randint(size, size*2)
        self.rock_size = random.randint(size//3, size//2)
        self.has_decoration = random.random() < 0.4  # 40% chance for decorations
        # Animation parameters
        self.wave_offset = random.random() * math.pi * 2
        self.wave_speed = random.uniform(0.01, 0.03)
        
    def draw(self, camera_x, camera_y, time_passed):
        # Only draw tiles that are visible on screen
        screen_x = self.x - camera_x
        screen_y = self.y - camera_y
        
        if -self.size <= screen_x <= WIDTH and -self.size <= screen_y <= HEIGHT:
            if self.type == "dirt":
                pygame.draw.rect(screen, DIRT, (screen_x, screen_y, self.size, self.size))
            elif self.type == "sand":
                pygame.draw.rect(screen, SAND, (screen_x, screen_y, self.size, self.size))
            elif self.type == "grass":
                pygame.draw.rect(screen, GRASS, (screen_x, screen_y, self.size, self.size))
            elif self.type == "forest":
                pygame.draw.rect(screen, DARK_GREEN, (screen_x, screen_y, self.size, self.size))
            elif self.type == "rock":
                pygame.draw.rect(screen, ROCK, (screen_x, screen_y, self.size, self.size))
            elif self.type == "path":
                pygame.draw.rect(screen, LIGHT_SAND, (screen_x, screen_y, self.size, self.size))
            elif self.type == "water":  # New water tile type
                water_color = (65, 105, 225)
                # Add wave animation
                wave = math.sin(time_passed * self.wave_speed + self.wave_offset) * 10
                water_rect = pygame.Rect(screen_x, screen_y, self.size, self.size)
                pygame.draw.rect(screen, water_color, water_rect)
                # Draw wave lines
                for i in range(0, self.size, 4):
                    wave_y = screen_y + i + math.sin(time_passed * 0.1 + i * 0.1) * 2
                    pygame.draw.line(screen, (120, 160, 255), 
                                    (screen_x, wave_y), 
                                    (screen_x + self.size, wave_y), 1)
            
            # Draw decorations (trees and rocks)
            if self.has_decoration:
                deco_x = screen_x + self.size//2 + self.decoration_offset_x
                deco_y = screen_y + self.size//2 + self.decoration_offset_y
                
                if self.type == "forest" and random.random() < 0.7:  # More trees in forest
                    # Draw tree
                    # Tree trunk
                    trunk_width = self.size//5
                    trunk_height = self.size//2
                    pygame.draw.rect(screen, TREE_TRUNK, 
                                    (deco_x - trunk_width//2, 
                                     deco_y - trunk_height//2, 
                                     trunk_width, trunk_height))
                    
                    # Tree foliage (triangular)
                    tree_top = deco_y - trunk_height//2 - self.tree_height//2
                    pygame.draw.polygon(screen, DARK_GREEN, [
                        (deco_x, tree_top),  # Top point
                        (deco_x - self.size//2, deco_y - trunk_height//2),  # Bottom left
                        (deco_x + self.size//2, deco_y - trunk_height//2)   # Bottom right
                    ])
                
                elif self.type == "rock" or (self.type in ["dirt", "grass", "sand"] and random.random() < 0.3):
                    # Draw rock
                    pygame.draw.circle(screen, ROCK, (deco_x, deco_y), self.rock_size)
                    # Add some detail to the rock
                    pygame.draw.circle(screen, (100, 100, 100), 
                                     (deco_x - self.rock_size//3, deco_y - self.rock_size//3), 
                                     self.rock_size//4)

class Map:
    def __init__(self, width, height, tile_size, difficulty=1):
        self.width = width * 3
        self.height = height * 3
        self.tile_size = tile_size
        self.tiles = []
        self.difficulty = difficulty
        self.generate_map()
        
    def generate_map(self):
        self.tiles = []
        num_tiles_x = self.width // self.tile_size
        num_tiles_y = self.height // self.tile_size
        
        # Start with all dirt
        for y in range(num_tiles_y):
            for x in range(num_tiles_x):
                self.tiles.append(Tile("dirt", x * self.tile_size, y * self.tile_size, self.tile_size))
        
        # Create multiple terrain regions
        num_regions = random.randint(4 + self.difficulty, 6 + self.difficulty * 2)
        region_centers = []
        
        for region in range(num_regions):
            center_x = random.randint(num_tiles_x // 4, num_tiles_x * 3 // 4)
            center_y = random.randint(num_tiles_y // 4, num_tiles_y * 3 // 4)
            region_radius = min(num_tiles_x, num_tiles_y) // random.randint(3, 5)
            region_centers.append((center_x, center_y))
            
            # Choose a biome type for this region
            biome_type = random.choice(["grass", "forest", "sand"])
            if self.difficulty >= 2 and random.random() < 0.3:
                biome_type = "water"  # Add water regions in higher difficulties
            
            for i, tile in enumerate(self.tiles):
                tile_x = i % num_tiles_x
                tile_y = i // num_tiles_x
                
                # Distance from center
                distance = math.sqrt((tile_x - center_x)**2 + (tile_y - center_y)**2)
                
                # Add some noise to make the terrain borders irregular
                noise = random.uniform(-0.3, 0.3)
                
                if distance < region_radius * (0.9 + noise):
                    # Core of the region
                    if distance < region_radius * 0.6:
                        if biome_type == "grass":
                            if random.random() < 0.15:
                                self.tiles[i].type = "forest"  # Some forest patches in grass
                            else:
                                self.tiles[i].type = "grass"
                        elif biome_type == "forest":
                            self.tiles[i].type = "forest"
                            if random.random() < 0.1:
                                self.tiles[i].type = "grass"  # Some grass clearings in forest
                        elif biome_type == "sand":
                            self.tiles[i].type = "sand"
                        elif biome_type == "water":
                            self.tiles[i].type = "water"
                            
                    # Edge of region blends with base terrain
                    else:
                        # Edges transition more naturally
                        if random.random() < 0.5:
                            self.tiles[i].type = biome_type
                        else:
                            self.tiles[i].type = "dirt"  # Base terrain
                            
                    # Add some rocky areas in all biomes
                    if random.random() < 0.03 + (0.01 * self.difficulty):
                        self.tiles[i].type = "rock"
        
        # Create paths between region centers
        for i in range(len(region_centers)):
            for j in range(i + 1, len(region_centers)):
                if random.random() < 0.7:  # Don't connect all regions
                    self.create_path(region_centers[i], region_centers[j], num_tiles_x, num_tiles_y)

    def create_path(self, region1, region2, num_tiles_x, num_tiles_y):
        x1, y1 = region1
        x2, y2 = region2
        
        # Simple linear interpolation to create a path with some randomness
        steps = int(max(abs(x2 - x1), abs(y2 - y1)) * 1.5)
        
        # Create a winding path
        path_points = [(x1, y1)]
        
        # Add some intermediate points for a winding path
        for _ in range(random.randint(1, 3)):
            # Random point deviation
            mid_x = (x1 + x2) // 2 + random.randint(-steps // 4, steps // 4)
            mid_y = (y1 + y2) // 2 + random.randint(-steps // 4, steps // 4)
            # Keep within map boundaries
            mid_x = max(0, min(mid_x, num_tiles_x - 1))
            mid_y = max(0, min(mid_y, num_tiles_y - 1))
            path_points.append((mid_x, mid_y))
        
        path_points.append((x2, y2))
        
        # Draw path segments
        for i in range(len(path_points) - 1):
            x1, y1 = path_points[i]
            x2, y2 = path_points[i + 1]
            
            segment_steps = max(abs(x2 - x1), abs(y2 - y1)) + 1
            for step in range(segment_steps + 1):
                x = int(x1 + (x2 - x1) * step / segment_steps)
                y = int(y1 + (y2 - y1) * step / segment_steps)
                
                if 0 <= x < num_tiles_x and 0 <= y < num_tiles_y:
                    index = y * num_tiles_x + x
                    if index < len(self.tiles):
                        self.tiles[index].type = "path"
                        
                        # Create a wider path by adding adjacent tiles
                        for dx in [-1, 0, 1]:
                            for dy in [-1, 0, 1]:
                                nx, ny = x + dx, y + dy
                                if 0 <= nx < num_tiles_x and 0 <= ny < num_tiles_y:
                                    nindex = ny * num_tiles_x + nx
                                    if nindex < len(self.tiles) and random.random() < 0.5:
                                        self.tiles[nindex].type = "path"
    
    def get_valid_position(self, size, exclude_tiles=None, min_distance=None, reference_point=None):
        if exclude_tiles is None:
            exclude_tiles = ["rock", "water"]  # Exclude rocks and water
            
        valid_tiles = [tile for tile in self.tiles if tile.type not in exclude_tiles]
        
        if not valid_tiles:
            return (self.width // 2, self.height // 2)
        
        # If we need to respect a minimum distance
        if min_distance and reference_point:
            ref_x, ref_y = reference_point
            valid_tiles = [tile for tile in valid_tiles if 
                          math.sqrt((tile.x + self.tile_size//2 - ref_x)**2 + 
                                   (tile.y + self.tile_size//2 - ref_y)**2) > min_distance]
        
        # If no valid tiles with distance constraint, use any valid tile
        if not valid_tiles and min_distance:
            valid_tiles = [tile for tile in self.tiles if tile.type not in exclude_tiles]
            
        if not valid_tiles:  # Still no valid tiles
            return (self.width // 2, self.height // 2)
            
        chosen_tile = random.choice(valid_tiles)
        return (chosen_tile.x + self.tile_size // 2, chosen_tile.y + self.tile_size // 2)
    
    def draw(self, camera_x, camera_y, time_passed):
        for tile in self.tiles:
            tile.draw(camera_x, camera_y, time_passed)

class PowerUp:
    def __init__(self, x, y, type):
        self.x = x
        self.y = y
        self.size = 15
        self.type = type  # "speed", "health", "magnet", "shield"
        self.collected = False
        self.animation_offset = 0
        self.colors = {
            "speed": BLUE,
            "health": RED,
            "magnet": PURPLE,
            "shield": GOLD
        }
        
    def draw(self, camera_x, camera_y, time_passed):
        if not self.collected:
            screen_x = self.x - camera_x
            screen_y = self.y - camera_y
            
            # Only draw if on screen
            if -self.size*2 <= screen_x <= WIDTH + self.size*2 and -self.size*2 <= screen_y <= HEIGHT + self.size*2:
                # Floating animation
                float_offset = math.sin(time_passed * 0.005 + self.animation_offset) * 5
                
                # Draw power-up
                color = self.colors.get(self.type, WHITE)
                pygame.draw.circle(screen, color, (screen_x, screen_y + float_offset), self.size)
                
                # Draw icon based on type
                if self.type == "speed":
                    # Draw lightning bolt
                    pygame.draw.polygon(screen, WHITE, [
                        (screen_x, screen_y + float_offset - 7),
                        (screen_x + 5, screen_y + float_offset),
                        (screen_x, screen_y + float_offset + 3),
                        (screen_x - 5, screen_y + float_offset)
                    ])
                elif self.type == "health":
                    # Draw cross
                    pygame.draw.rect(screen, WHITE, (screen_x - 2, screen_y + float_offset - 6, 4, 12))
                    pygame.draw.rect(screen, WHITE, (screen_x - 6, screen_y + float_offset - 2, 12, 4))
                elif self.type == "magnet":
                    # Draw magnet
                    pygame.draw.rect(screen, WHITE, (screen_x - 5, screen_y + float_offset - 5, 10, 3))
                    pygame.draw.rect(screen, WHITE, (screen_x - 5, screen_y + float_offset - 5, 3, 10))
                    pygame.draw.rect(screen, WHITE, (screen_x + 2, screen_y + float_offset - 5, 3, 10))
                elif self.type == "shield":
                    # Draw shield
                    pygame.draw.arc(screen, WHITE, 
                                  (screen_x - 6, screen_y + float_offset - 6, 12, 12),
                                  math.pi/4, math.pi*7/4, 2)

class Explorer:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.base_speed = 5
        self.speed = self.base_speed
        self.size = 20
        self.treasures = 0
        self.coins = 0
        self.keys = 0
        self.hearts = 3
        self.max_hearts = 5
        self.frame = 0
        self.direction = "down"
        self.moving = False
        self.last_move_time = 0
        self.animation_speed = 150  # milliseconds per frame
        self.active_powerups = {
            "speed": 0,
            "magnet": 0,
            "shield": 0
        }
        # Particles
        self.particles = []
        self.magnet_radius = 150  # Range for magnet power-up
        self.name = "Explorer"
        
    def draw(self, camera_x, camera_y, time_passed):
        # Calculate screen position
        screen_x = self.x - camera_x
        screen_y = self.y - camera_y
        
        # Update particles first
        self.update_particles()
        
        # Draw particles behind player
        for particle in self.particles:
            particle.draw(camera_x, camera_y)
        
        # Draw shield if active
        if self.active_powerups["shield"] > 0:
            shield_radius = self.size + 10
            shield_color = (255, 215, 0, min(200, int(255 * (self.active_powerups["shield"] / 600))))
            shield_surface = pygame.Surface((shield_radius*2, shield_radius*2), pygame.SRCALPHA)
            pygame.draw.circle(shield_surface, shield_color, (shield_radius, shield_radius), shield_radius)
            screen.blit(shield_surface, (screen_x - shield_radius, screen_y - shield_radius))
        
        # Draw the explorer based on direction and animation frame
        if self.direction == "down":
            # Body
            pygame.draw.circle(screen, BLUE, (screen_x, screen_y), self.size)
            # Head
            pygame.draw.circle(screen, (255, 213, 170), (screen_x, screen_y - self.size - 5), self.size // 2)
            # Eyes
            eye_offset = 2 if self.frame % 2 == 0 else 0
            pygame.draw.circle(screen, BLACK, (screen_x - 5, screen_y - self.size - 5 - eye_offset), 3)
            pygame.draw.circle(screen, BLACK, (screen_x + 5, screen_y - self.size - 5 - eye_offset), 3)
            
        elif self.direction == "up":
            # Body
            pygame.draw.circle(screen, BLUE, (screen_x, screen_y), self.size)
            # Head (from behind)
            pygame.draw.circle(screen, (200, 160, 120), (screen_x, screen_y - self.size - 5), self.size // 2)
            # Hair
            pygame.draw.ellipse(screen, (100, 50, 0), (screen_x - 8, screen_y - self.size - 10, 16, 10))
            
        elif self.direction == "left":
            # Body
            pygame.draw.circle(screen, BLUE, (screen_x, screen_y), self.size)
            # Head
            pygame.draw.circle(screen, (255, 213, 170), (screen_x - self.size // 2, screen_y - self.size // 2), self.size // 2)
            # Eye (only one visible from side)
            pygame.draw.circle(screen, BLACK, (screen_x - self.size // 2 - 3, screen_y - self.size // 2), 3)
            
        elif self.direction == "right":
            # Body
            pygame.draw.circle(screen, BLUE, (screen_x, screen_y), self.size)
            # Head
            pygame.draw.circle(screen, (255, 213, 170), (screen_x + self.size // 2, screen_y - self.size // 2), self.size // 2)
            # Eye (only one visible from side)
            pygame.draw.circle(screen, BLACK, (screen_x + self.size // 2 + 3, screen_y - self.size // 2), 3)
        
        # Draw name above player
        name_text = font_tiny.render(self.name, True, WHITE)
        screen.blit(name_text, (screen_x - name_text.get_width()//2, screen_y - self.size*2 - 20))
        
        # Draw active powerups
        powerup_x = screen_x - 20
        powerup_y = screen_y - self.size - 25
        for powerup, time_left in self.active_powerups.items():
            if time_left > 0:
                if powerup == "speed":
                    color = BLUE
                elif powerup == "magnet":
                    color = PURPLE
                elif powerup == "shield":
                    color = GOLD
                else:
                    color = WHITE
                    
                pygame.draw.circle(screen, color, (powerup_x, powerup_y), 5)
                powerup_x += 15
        
        # Draw magnet radius if active
        if self.active_powerups["magnet"] > 0:
            pygame.draw.circle(screen, (PURPLE[0], PURPLE[1], PURPLE[2], 50), 
                             (screen_x, screen_y), self.magnet_radius, 1)
            
    def update_particles(self):
        # Remove dead particles
        self.particles = [p for p in self.particles if not p.is_dead()]
        
        # Update remaining particles
        for particle in self.particles:
            particle.update()
            
        # Add new particles based on power-ups
        if self.active_powerups["speed"] > 0 and random.random() < 0.2:
            self.particles.append(Particle(
                self.x + random.uniform(-self.size/2, self.size/2),
                self.y + random.uniform(-self.size/2, self.size/2),
                BLUE,
                size=random.uniform(2, 4),
                lifetime=random.randint(10, 20)
            ))
            
    def apply_powerup(self, powerup_type):
        if powerup_type == "speed":
            self.active_powerups["speed"] = 600  # 10 seconds at 60 FPS
            self.speed = self.base_speed * 1.5
        elif powerup_type == "health":
            self.hearts = min(self.hearts + 1, self.max_hearts)
        elif powerup_type == "magnet":
            self.active_powerups["magnet"] = 600  # 10 seconds
        elif powerup_type == "shield":
            self.active_powerups["shield"] = 600  # 10 seconds
    
    def update_powerups(self):
        # Decrease timers for active powerups
        for powerup in self.active_powerups:
            if self.active_powerups[powerup] > 0:
                self.active_powerups[powerup] -= 1
                
                # Reset effects when powerup expires
                if self.active_powerups[powerup] <= 0:
                    if powerup == "speed":
                        self.speed = self.base_speed
        
    def move(self, keys, game_map, camera_x, camera_y, current_time):
        new_x, new_y = self.x, self.y
        self.moving = False
        old_direction = self.direction
        
        if keys[pygame.K_LEFT] and self.x > self.size:
            new_x -= self.speed
            self.direction = "left"
            self.moving = True
        if keys[pygame.K_RIGHT] and self.x < game_map.width - self.size:
            new_x += self.speed
            self.direction = "right"
            self.moving = True
        if keys[pygame.K_UP] and self.y > self.size:
            new_y -= self.speed
            self.direction = "up"
            self.moving = True
        if keys[pygame.K_DOWN] and self.y < game_map.height - self.size:
            new_y += self.speed
            self.direction = "down"
            self.moving = True
            
        # Update animation frame if moving
        if self.moving:
            if current_time - self.last_move_time > self.animation_speed:
                self.frame = (self.frame + 1) % 4
                self.last_move_time = current_time
                # Play walk sound occasionally when frame changes
                if self.frame == 0 and random.random() < 0.3:
                    play_sound('walk')
        else:
            self.frame = 0
            
        # Check if new position is valid (not on rocks or water)
        tile_x = new_x // game_map.tile_size
        tile_y = new_y // game_map.tile_size
        
        if 0 <= tile_x < game_map.width // game_map.tile_size and 0 <= tile_y < game_map.height // game_map.tile_size:
            tile_index = tile_y * (game_map.width // game_map.tile_size) + tile_x
            
            if 0 <= tile_index < len(game_map.tiles):
                tile_type = game_map.tiles[tile_index].type
                if tile_type not in ["rock", "water"] or (tile_type == "water" and self.active_powerups["shield"] > 0):
                    self.x, self.y = new_x, new_y
            
    def collides_with(self, entity):
        distance = math.sqrt((self.x - entity.x)**2 + (self.y - entity.y)**2)
        return distance < self.size + entity.size
    
    def in_magnet_range(self, entity):
        if self.active_powerups["magnet"] <= 0:
            return False
        
        distance = math.sqrt((self.x - entity.x)**2 + (self.y - entity.y)**2)
        return distance < self.magnet_radius

class Treasure:
    def __init__(self, x, y, treasure_type="normal"):
        self.x = x
        self.y = y
        self.size = 15
        self.collected = False
        self.animation_offset = random.random() * math.pi * 2
        self.treasure_type = treasure_type  # "normal", "special", "rare"
        self.value = {
            "normal": 1,
            "special": 3,
            "rare": 5
        }.get(treasure_type, 1)
        
        # Color by type
        self.color = {
            "normal": GOLD,
            "special": (255, 128, 0),  # Orange
            "rare": (138, 43, 226)   # Purple
        }.get(treasure_type, GOLD)
        
    def draw(self, camera_x, camera_y, time_passed):
        if not self.collected:
            screen_x = self.x - camera_x
            screen_y = self.y - camera_y
            
            # Only draw if on screen
            if -self.size <= screen_x <= WIDTH + self.size and -self.size <= screen_y <= HEIGHT + self.size:
                # Floating animation
                float_offset = math.sin(time_passed * 0.005 + self.animation_offset) * 5
                
                # Draw chest with slight 3D effect
                chest_width = self.size * 1.2
                chest_height = self.size * 0.8
                
                # Main body of chest
                pygame.draw.rect(screen, self.color, 
                              (screen_x - chest_width//2, 
                               screen_y - chest_height//2 + float_offset, 
                               chest_width, chest_height))
                
                # Chest top
                pygame.draw.rect(screen, (self.color[0]//2, self.color[1]//2, self.color[2]//2), 
                              (screen_x - chest_width//2, 
                               screen_y - chest_height//2 + float_offset - chest_height//4, 
                               chest_width, chest_height//4))
                
                # Chest lock
                pygame.draw.rect(screen, (200, 200, 200), 
                              (screen_x - 5, 
                               screen_y - 5 + float_offset, 
                               10, 10))
                
                # Sparkling effect
                if random.random() < 0.1:
                    sparkle_x = screen_x + random.randint(-self.size, self.size)
                    sparkle_y = screen_y + random.randint(-self.size, self.size) + float_offset
                    pygame.draw.line(screen, WHITE, 
                                  (sparkle_x-2, sparkle_y), 
                                  (sparkle_x+2, sparkle_y), 2)
                    pygame.draw.line(screen, WHITE, 
                                  (sparkle_x, sparkle_y-2), 
                                  (sparkle_x, sparkle_y+2), 2)
                
                # Show value
                if self.treasure_type != "normal":
                    value_text = font_tiny.render(str(self.value), True, WHITE)
                    screen.blit(value_text, (screen_x + self.size, screen_y - self.size))

class Key:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.size = 12
        self.collected = False
        self.animation_offset = random.random() * math.pi * 2
    
    def draw(self, camera_x, camera_y, time_passed):
        if not self.collected:
            screen_x = self.x - camera_x
            screen_y = self.y - camera_y
            
            # Only draw if on screen
            if -self.size <= screen_x <= WIDTH + self.size and -self.size <= screen_y <= HEIGHT + self.size:
                # Floating animation
                float_offset = math.sin(time_passed * 0.005 + self.animation_offset) * 5
                
                # Draw key
                # Key head
                pygame.draw.circle(screen, GOLD, (screen_x, screen_y + float_offset), self.size//2)
                # Key stem
                pygame.draw.rect(screen, GOLD, 
                               (screen_x, screen_y + float_offset, 
                                self.size//4, self.size*1.5))
                # Key teeth
                pygame.draw.rect(screen, GOLD, 
                               (screen_x + self.size//4, screen_y + float_offset + self.size, 
                                self.size//2, self.size//4))
                pygame.draw.rect(screen, GOLD, 
                               (screen_x + self.size//4, screen_y + float_offset + self.size*1.25, 
                                self.size//2, self.size//4))
                
                # Sparkling effect
                if random.random() < 0.1:
                    sparkle_x = screen_x + random.randint(-self.size, self.size)
                    sparkle_y = screen_y + random.randint(-self.size, self.size) + float_offset
                    pygame.draw.line(screen, WHITE, 
                                  (sparkle_x-2, sparkle_y), 
                                  (sparkle_x+2, sparkle_y), 2)
                    pygame.draw.line(screen, WHITE, 
                                  (sparkle_x, sparkle_y-2), 
                                  (sparkle_x, sparkle_y+2), 2)

class Coin:
    def __init__(self, x, y, value=1):
        self.x = x
        self.y = y
        self.size = 10
        self.collected = False
        self.animation_offset = random.random() * math.pi * 2
        self.value = value
        self.color = GOLD if value == 1 else ORANGE if value == 5 else PURPLE
    
    def draw(self, camera_x, camera_y, time_passed):
        if not self.collected:
            screen_x = self.x - camera_x
            screen_y = self.y - camera_y
            
            # Only draw if on screen
            if -self.size <= screen_x <= WIDTH + self.size and -self.size <= screen_y <= HEIGHT + self.size:
                # Floating animation
                float_offset = math.sin(time_passed * 0.005 + self.animation_offset) * 3
                
                # Draw coin with 3D effect (oval that changes with time)
                width_factor = abs(math.sin(time_passed * 0.01 + self.animation_offset)) * 0.5 + 0.5
                pygame.draw.ellipse(screen, self.color, 
                                  (screen_x - self.size * width_factor, 
                                   screen_y - self.size + float_offset, 
                                   self.size * 2 * width_factor, 
                                   self.size * 2))
                
                # Coin edge highlight
                pygame.draw.ellipse(screen, (255, 255, 200), 
                                  (screen_x - self.size * width_factor + 2, 
                                   screen_y - self.size + float_offset + 2, 
                                   self.size * 2 * width_factor - 4, 
                                   self.size * 2 - 4), 1)
                
                # Show value for special coins
                if self.value > 1:
                    value_text = font_tiny.render(str(self.value), True, WHITE)
                    screen.blit(value_text, (screen_x - value_text.get_width()//2, 
                                         screen_y - self.size//2 + float_offset))

class Enemy:
    def __init__(self, x, y, enemy_type="ghost"):
        self.x = x
        self.y = y
        self.size = 18
        self.speed = random.uniform(1, 2.5)
        self.enemy_type = enemy_type
        self.direction = random.choice(["up", "down", "left", "right"])
        self.direction_change_time = 0
        self.frame = 0
        self.animation_speed = 200
        self.last_frame_time = 0
        self.aggro_range = 250
        self.color = {
            "ghost": (200, 200, 255),
            "goblin": (100, 200, 100),
            "slime": (100, 200, 255)
        }.get(enemy_type, (200, 200, 255))
        
    def draw(self, camera_x, camera_y, time_passed):
        screen_x = self.x - camera_x
        screen_y = self.y - camera_y
        
        # Only draw if on screen
        if -self.size*2 <= screen_x <= WIDTH + self.size*2 and -self.size*2 <= screen_y <= HEIGHT + self.size*2:
            # Handle different enemy types
            if self.enemy_type == "ghost":
                # Ghost body
                ghost_height = self.size * 1.5
                # Base body with ripple effect
                wave = math.sin(time_passed * 0.01) * 3
                
                # Translucent effect
                ghost_surface = pygame.Surface((self.size*2 + abs(wave)*2, ghost_height*1.5), pygame.SRCALPHA)
                
                # Main ghost body
                pygame.draw.ellipse(ghost_surface, (*self.color, 180), 
                                  (0, 0, self.size*2, self.size*2))
                
                # Wavy bottom
                for i in range(3):
                    offset = i * (self.size*2 // 3)
                    bottom_wave = math.sin(time_passed * 0.01 + i) * 5
                    pygame.draw.ellipse(ghost_surface, (*self.color, 150), 
                                     (offset, self.size + bottom_wave, 
                                      self.size*2//3, ghost_height - self.size))
                
                # Eyes
                eye_offset = 5 if self.frame % 2 == 0 else 0
                pygame.draw.circle(ghost_surface, (0, 0, 0, 200), (self.size//2, self.size//2 + eye_offset), 4)
                pygame.draw.circle(ghost_surface, (0, 0, 0, 200), (self.size*3//2, self.size//2 + eye_offset), 4)
                
                screen.blit(ghost_surface, (screen_x - self.size - abs(wave), screen_y - self.size))
                
            elif self.enemy_type == "goblin":
                # Goblin body
                pygame.draw.circle(screen, self.color, (screen_x, screen_y), self.size)
                
                # Face direction
                face_offset = 8
                if self.direction == "left":
                    face_x = screen_x - face_offset
                elif self.direction == "right":
                    face_x = screen_x + face_offset
                else:
                    face_x = screen_x
                
                if self.direction == "up":
                    face_y = screen_y - face_offset
                elif self.direction == "down":
                    face_y = screen_y + face_offset
                else:
                    face_y = screen_y
                
                # Face
                pygame.draw.circle(screen, (150, 100, 50), (face_x, face_y), self.size//2)
                
                # Eyes
                pygame.draw.circle(screen, (255, 0, 0), (face_x - 3, face_y - 2), 2)
                pygame.draw.circle(screen, (255, 0, 0), (face_x + 3, face_y - 2), 2)
                
                # Goblin ears
                ear_size = self.size // 3
                pygame.draw.ellipse(screen, self.color, (face_x - self.size//2 - ear_size, face_y - ear_size, ear_size*2, ear_size))
                pygame.draw.ellipse(screen, self.color, (face_x + self.size//2 - ear_size, face_y - ear_size, ear_size*2, ear_size))
                
            elif self.enemy_type == "slime":
                # Slime body with bounce animation
                bounce = abs(math.sin(time_passed * 0.008)) * 10
                slime_height = self.size + bounce
                
                # Base slime
                pygame.draw.ellipse(screen, self.color, 
                                  (screen_x - self.size, 
                                   screen_y - slime_height//2, 
                                   self.size * 2, 
                                   slime_height))
                
                # Eyes
                eye_y = screen_y - slime_height//4
                pygame.draw.circle(screen, (0, 0, 0), (screen_x - 5, eye_y), 3)
                pygame.draw.circle(screen, (0, 0, 0), (screen_x + 5, eye_y), 3)
                
                # Slime drips
                if random.random() < 0.1:
                    drip_x = screen_x + random.randint(-self.size + 3, self.size - 3)
                    pygame.draw.line(screen, self.color, 
                                  (drip_x, screen_y + slime_height//2), 
                                  (drip_x, screen_y + slime_height//2 + random.randint(3, 8)), 2)
    
    def update(self, game_map, player, current_time):
        # Update animation
        if current_time - self.last_frame_time > self.animation_speed:
            self.frame = (self.frame + 1) % 4
            self.last_frame_time = current_time
        
        # Calculate distance to player
        dist_to_player = math.sqrt((self.x - player.x)**2 + (self.y - player.y)**2)
        
        # If player has shield, enemies stay away
        if player.active_powerups["shield"] > 0 and dist_to_player < self.aggro_range:
            # Run away from player
            angle = math.atan2(self.y - player.y, self.x - player.x)
            new_x = self.x + math.cos(angle) * self.speed
            new_y = self.y + math.sin(angle) * self.speed
            
            # Update direction based on movement
            if abs(math.cos(angle)) > abs(math.sin(angle)):
                self.direction = "right" if math.cos(angle) > 0 else "left"
            else:
                self.direction = "down" if math.sin(angle) > 0 else "up"
                
        # Chase player if in range
        elif dist_to_player < self.aggro_range:
            angle = math.atan2(player.y - self.y, player.x - self.x)
            new_x = self.x + math.cos(angle) * self.speed
            new_y = self.y + math.sin(angle) * self.speed
            
            # Update direction based on movement
            if abs(math.cos(angle)) > abs(math.sin(angle)):
                self.direction = "right" if math.cos(angle) > 0 else "left"
            else:
                self.direction = "down" if math.sin(angle) > 0 else "up"
                
        else:
            # Random movement
            if current_time - self.direction_change_time > 2000:  # Change direction every 2 seconds
                self.direction = random.choice(["up", "down", "left", "right"])
                self.direction_change_time = current_time
            
            if self.direction == "up":
                new_y = self.y - self.speed
                new_x = self.x
            elif self.direction == "down":
                new_y = self.y + self.speed
                new_x = self.x
            elif self.direction == "left":
                new_x = self.x - self.speed
                new_y = self.y
            else:  # right
                new_x = self.x + self.speed
                new_y = self.y
        
        # Check if new position is valid (not on rocks)
        tile_size = game_map.tile_size
        tile_x = int(new_x // tile_size)
        tile_y = int(new_y // tile_size)
        
        map_width_tiles = game_map.width // tile_size
        map_height_tiles = game_map.height // tile_size
        
        if 0 <= tile_x < map_width_tiles and 0 <= tile_y < map_height_tiles:
            tile_index = tile_y * map_width_tiles + tile_x
            
            if 0 <= tile_index < len(game_map.tiles):
                tile_type = game_map.tiles[tile_index].type
                
                # Different enemies have different movement restrictions
                if self.enemy_type == "ghost":
                    # Ghosts can go anywhere except water
                    if tile_type != "water":
                        self.x, self.y = new_x, new_y
                elif self.enemy_type == "slime":
                    # Slimes prefer water and avoid rocks
                    if tile_type != "rock":
                        self.x, self.y = new_x, new_y
                        # Slimes are faster in water
                        if tile_type == "water":
                            self.x += math.cos(math.atan2(new_y - self.y, new_x - self.x)) * self.speed * 0.5
                            self.y += math.sin(math.atan2(new_y - self.y, new_x - self.x)) * self.speed * 0.5
                else:  # goblin and others
                    # Normal enemies avoid water and rocks
                    if tile_type not in ["rock", "water"]:
                        self.x, self.y = new_x, new_y
        
        # Keep within map bounds
        self.x = max(self.size, min(self.x, game_map.width - self.size))
        self.y = max(self.size, min(self.y, game_map.height - self.size))

class GameSystem:
    def __init__(self):
        self.state = MENU
        self.difficulty = 1
        self.level = 1
        self.score = 0
        self.high_score = 0
        self.game_map = None
        self.player = None
        self.treasures = []
        self.keys = []
        self.coins = []
        self.powerups = []
        self.enemies = []
        self.camera_x = 0
        self.camera_y = 0
        self.challenges = []
        self.current_challenge = None
        self.challenge_timer = 0
        self.challenge_result = None
        self.transition_alpha = 255
        self.fade_direction = -1  # -1 for fade in, 1 for fade out
        self.shop_items = []
        self.game_time = 0
        self.level_start_time = 0
        self.level_time_limit = 300  # 5 minutes in seconds
        self.paused = False
        self.tutorial_page = 0
        self.story_page = 0
        self.player_name = ""
        self.input_active = False
        self.show_map = False
        self.map_zoom = 0.2
        self.particles = []
        self.messages = []  # For in-game notifications
        self.message_fade = 255
        self.completion_stats = {
            "treasures_found": 0,
            "keys_collected": 0,
            "coins_collected": 0,
            "powerups_used": 0,
            "enemies_avoided": 0,
            "distance_traveled": 0,
            "challenges_completed": 0
        }
        self.initialize_shop()
        
    def initialize_shop(self):
        self.shop_items = [
            {"name": "Extra Heart", "description": "Increases max health by 1", "cost": 50, "effect": "health"},
            {"name": "Speed Boost", "description": "Permanent speed increase", "cost": 40, "effect": "speed"},
            {"name": "Key", "description": "Get an extra key", "cost": 30, "effect": "key"},
            {"name": "Magnet", "description": "Active magnet power-up", "cost": 25, "effect": "magnet"},
            {"name": "Shield", "description": "Active shield power-up", "cost": 35, "effect": "shield"}
        ]
        
    def add_message(self, text, color=WHITE):
        self.messages.append({"text": text, "color": color, "time": 180})  # Show for 3 seconds (60 fps * 3)
        
    def update_messages(self):
        # Update existing messages
        for message in self.messages:
            message["time"] -= 1
            
        # Remove expired messages
        self.messages = [msg for msg in self.messages if msg["time"] > 0]
        
    def draw_messages(self):
        # Draw messages at the top center of the screen
        y_offset = 50
        for message in self.messages:
            # Fade out as time expires
            alpha = min(255, message["time"] * 3)
            color = (*message["color"][:3], alpha) if len(message["color"]) > 3 else message["color"]
            
            message_text = font_medium.render(message["text"], True, color)
            screen.blit(message_text, (WIDTH//2 - message_text.get_width()//2, y_offset))
            y_offset += 40
    
    def start_new_game(self):
        # Initialize game map
        self.game_map = Map(WIDTH, HEIGHT, 50, self.difficulty)
        
        # Create player at valid location
        player_pos = self.game_map.get_valid_position(20)
        self.player = Explorer(*player_pos)
        
        # Set player name if empty
        if not self.player_name:
            self.player_name = "Explorer"
        self.player.name = self.player_name
        
        # Reset game variables
        self.score = 0
        self.level = 1
        self.treasures = []
        self.keys = []
        self.coins = []
        self.powerups = []
        self.enemies = []
        self.challenges = []
        self.messages = []
        self.game_time = 0
        self.level_start_time = 0
        self.show_map = False
        
        # Reset completion stats
        for stat in self.completion_stats:
            self.completion_stats[stat] = 0
        
        # Spawn initial game objects
        self.spawn_level_objects()
        
        # Initialize camera position
        self.center_camera_on_player()
        
        # Set game state to playing
        self.state = PLAYING
        
    def spawn_level_objects(self):
        # Clear existing objects
        self.treasures = []
        self.keys = []
        self.coins = []
        self.powerups = []
        self.enemies = []
        
        # Number of objects scales with level and difficulty
        num_treasures = 3 + self.level + self.difficulty
        num_keys = max(2, min(num_treasures - 1, 5 + self.level // 2))
        num_coins = 10 + self.level * 3 + self.difficulty * 2
        num_powerups = 1 + self.level // 2
        num_enemies = self.difficulty * 2 + self.level
        
        # Spawn treasures
        for _ in range(num_treasures):
            # Make some treasures special or rare
            treasure_type = "normal"
            if random.random() < 0.2:
                treasure_type = "special"
            elif random.random() < 0.1:
                treasure_type = "rare"
            
            # Place treasure at valid position, away from player
            treasure_pos = self.game_map.get_valid_position(15, ["water", "rock"], 
                                                          300, (self.player.x, self.player.y))
            self.treasures.append(Treasure(*treasure_pos, treasure_type))
        
        # Spawn keys
        for _ in range(num_keys):
            key_pos = self.game_map.get_valid_position(12, ["water", "rock"])
            self.keys.append(Key(*key_pos))
        
        # Spawn coins
        for _ in range(num_coins):
            coin_value = 1
            if random.random() < 0.1:
                coin_value = 5
            elif random.random() < 0.05:
                coin_value = 10
                
            coin_pos = self.game_map.get_valid_position(10)
            self.coins.append(Coin(*coin_pos, coin_value))
        
        # Spawn power-ups
        powerup_types = ["speed", "health", "magnet", "shield"]
        for _ in range(num_powerups):
            powerup_type = random.choice(powerup_types)
            powerup_pos = self.game_map.get_valid_position(15, ["water", "rock"])
            self.powerups.append(PowerUp(*powerup_pos, powerup_type))
        
        # Spawn enemies
        enemy_types = ["ghost", "goblin", "slime"]
        for _ in range(num_enemies):
            enemy_type = random.choice(enemy_types)
            # Ensure enemies spawn away from player
            enemy_pos = self.game_map.get_valid_position(18, ["rock"], 
                                                       400, (self.player.x, self.player.y))
            self.enemies.append(Enemy(*enemy_pos, enemy_type))
    
    def center_camera_on_player(self):
        self.camera_x = self.player.x - WIDTH // 2
        self.camera_y = self.player.y - HEIGHT // 2
        
        # Keep camera within map bounds
        self.camera_x = max(0, min(self.camera_x, self.game_map.width - WIDTH))
        self.camera_y = max(0, min(self.camera_y, self.game_map.height - HEIGHT))
    
    def check_collisions(self):
        # Check treasure collisions
        for treasure in self.treasures:
            if not treasure.collected and self.player.collides_with(treasure):
                if self.player.keys > 0:
                    treasure.collected = True
                    self.player.keys -= 1
                    self.player.treasures += treasure.value
                    self.score += treasure.value * 50
                    self.completion_stats["treasures_found"] += 1
                    play_sound('collect_treasure')
                    self.add_message(f"Found a treasure! +{treasure.value * 50} points", GOLD)
                else:
                    self.add_message("Need a key to open this treasure!", WHITE)
        
        # Check key collisions
        for key in self.keys:
            if not key.collected and self.player.collides_with(key):
                key.collected = True
                self.player.keys += 1
                self.score += 20
                self.completion_stats["keys_collected"] += 1
                play_sound('collect_key')
                self.add_message("Found a key! +20 points", GOLD)
        
        # Check coin collisions
        for coin in self.coins:
            in_range = (self.player.active_powerups["magnet"] > 0 and 
                       self.player.in_magnet_range(coin))
            
            # Move coin toward player if magnet is active
            if in_range and not coin.collected:
                dx = self.player.x - coin.x
                dy = self.player.y - coin.y
                dist = max(1, math.sqrt(dx*dx + dy*dy))
                coin.x += (dx / dist) * 5
                coin.y += (dy / dist) * 5
            
            # Check collision
            if not coin.collected and self.player.collides_with(coin):
                coin.collected = True
                self.player.coins += coin.value
                self.score += coin.value * 10
                self.completion_stats["coins_collected"] += coin.value
                play_sound('collect_key')  # Use key sound for coins too
                if coin.value > 1:
                    self.add_message(f"Collected a valuable coin! +{coin.value * 10} points", GOLD)
        
        # Check power-up collisions
        for powerup in self.powerups:
            if not powerup.collected and self.player.collides_with(powerup):
                powerup.collected = True
                self.player.apply_powerup(powerup.type)
                self.score += 30
                self.completion_stats["powerups_used"] += 1
                play_sound('level_up')
                self.add_message(f"Power-up: {powerup.type.title()}! +30 points", BLUE)
        
        # Check enemy collisions
        for enemy in self.enemies:
            if self.player.collides_with(enemy):
                if self.player.active_powerups["shield"] > 0:
                    # Shield protects from damage but gets used up
                    self.player.active_powerups["shield"] = 0
                    play_sound('wrong_answer')  # Use wrong answer sound for shield hit
                    self.add_message("Shield protected you!", GOLD)
                else:
                    # Player takes damage
                    self.player.hearts -= 1
                    play_sound('wrong_answer')
                    self.add_message("Ouch! Lost a heart!", RED)
                    
                    # Push player away from enemy
                    angle = math.atan2(self.player.y - enemy.y, self.player.x - enemy.x)
                    self.player.x += math.cos(angle) * 50
                    self.player.y += math.sin(angle) * 50
                    
                    # Keep player within bounds
                    self.player.x = max(self.player.size, min(self.player.x, self.game_map.width - self.player.size))
                    self.player.y = max(self.player.size, min(self.player.y, self.game_map.height - self.player.size))
                    
                    # Check for game over
                    if self.player.hearts <= 0:
                        self.state = GAME_OVER
                        play_sound('

